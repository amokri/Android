// --- file: MainActivity.kt ---
package com.ahm.mytime

import android.annotation.SuppressLint
import android.os.Bundle
import android.widget.RemoteViews
import androidx.appcompat.app.AppCompatActivity
import androidx.work.*
import java.util.concurrent.TimeUnit
import android.app.Activity
import android.appwidget.AppWidgetManager
import android.content.Intent
import android.view.View


class MainActivity : AppCompatActivity() {

    companion object {
        private const val PRAYER_TIME_WORK_NAME = "PrayerTimeFetchWork"
        private const val INITIAL_PRAYER_TIME_WORK_NAME = "InitialPrayerTimeFetch"
    }

    @SuppressLint(
        "ResourceType"
    )
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

//        // Create a RemoteViews instance
//        val views = RemoteViews(packageName, R.layout.widget_prayer_time)
//        // Set the RemoteViews as the content view
//        setContentView(views.viewId)

        schedulePrayerTimeWorker()
    }

    private fun schedulePrayerTimeWorker() {
        val constraints = createNetworkConstraints()

        schedulePeriodicPrayerTimeWork(constraints)
        scheduleInitialPrayerTimeWork(constraints)
    }

    private fun createNetworkConstraints(): Constraints {
        return Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
    }

    private fun schedulePeriodicPrayerTimeWork(constraints: Constraints) {
        val periodicWorkRequest = PeriodicWorkRequestBuilder<PrayerTimesFetchWorker>(
            repeatInterval = 24,
            repeatIntervalTimeUnit = TimeUnit.HOURS
        )
            .setConstraints(constraints)
            .build()

        WorkManager.getInstance(this).enqueueUniquePeriodicWork(
            PRAYER_TIME_WORK_NAME,
            ExistingPeriodicWorkPolicy.KEEP,
            periodicWorkRequest
        )
    }

    private fun scheduleInitialPrayerTimeWork(constraints: Constraints) {
        val oneTimeWorkRequest = OneTimeWorkRequestBuilder<PrayerTimesFetchWorker>()
            .setConstraints(constraints)
            .build()

        WorkManager.getInstance(this).enqueueUniqueWork(
            INITIAL_PRAYER_TIME_WORK_NAME,
            ExistingWorkPolicy.KEEP,
            oneTimeWorkRequest
        )
    }
}

// --- file: PrayerTimesFetchWorker.kt ---
package com.ahm.mytime

import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import org.jsoup.Jsoup
import java.util.*

class PrayerTimesFetchWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    companion object {
        const val PRAYER_PREFS = "PrayerTimePrefs"
        private const val TAG = "PrayerTimesFetchWorker"
    }

    override suspend fun doWork(): Result {
        val prefsEditor = applicationContext.getSharedPreferences(PRAYER_PREFS, Context.MODE_PRIVATE).edit()
        var prayerTimesSuccess = false
        var hijriDateSuccess = false

        try {
            prayerTimesSuccess = fetchAndSavePrayerTimes(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching prayer times", e)
        }

        try {
            hijriDateSuccess = fetchAndSaveMonthlyHijriDates(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching Hijri dates", e)
        }

        prefsEditor.apply()

        return if (prayerTimesSuccess && hijriDateSuccess) {
            triggerWidgetUpdate()
            Result.success()
        } else {
            Log.e(TAG, "One or more fetch tasks failed. PrayerSuccess: $prayerTimesSuccess, HijriSuccess: $hijriDateSuccess")
            Result.failure()
        }
    }

    private fun fetchAndSavePrayerTimes(editor: SharedPreferences.Editor): Boolean {
        val prayerUrl = "https://www.waktusolat.my/kedah/kdh05"
        Log.d(TAG, "Fetching monthly prayer times from: $prayerUrl")

        try {
            val prayerDoc = Jsoup.connect(prayerUrl).get()
            val table = prayerDoc.select("table#waktu-semua").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find prayer time table or it has no rows.")
                return false
            }

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 8) {
                    val date = cells[0].select("h6").text()

                    if (date.isNotBlank()) {
                        val fajr = cells[2].text()
                        val sunrise = cells[3].text()
                        val dhuhr = cells[4].text()
                        val asr = cells[5].text()
                        val maghrib = cells[6].text()
                        val isha = cells[7].text()

                        editor.putString("fajr_$date", fajr)
                        editor.putString("sunrise_$date", sunrise)
                        editor.putString("dhuhr_$date", dhuhr)
                        editor.putString("asr_$date", asr)
                        editor.putString("maghrib_$date", maghrib)
                        editor.putString("isha_$date", isha)
                        rowsProcessed++
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored prayer times for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid prayer time rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly prayer times", e)
            return false
        }
    }

    private fun fetchAndSaveMonthlyHijriDates(editor: SharedPreferences.Editor): Boolean {
        val hijriUrl = "https://timesprayer.com/en/hijri-date-in-malaysia.html"
        Log.d(TAG, "Fetching monthly Hijri dates from: $hijriUrl")

        try {
            val doc = Jsoup.connect(hijriUrl).get()
            val table = doc.select("div.prayertable.calendarTb table").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find Hijri date table or it has no rows.")
                return false
            }

            val gregorianParseFormat = SimpleDateFormat("EEEE, MMMM d, yyyy", Locale.ENGLISH)
            val keyStorageFormat = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 2) {
                    val gregorianDateStr = cells[0].text()
                    val hijriDateStr = cells[1].select("strong").text()

                    if (gregorianDateStr.isNotBlank() && hijriDateStr.isNotBlank()) {
                        try {
                            val parsedDate = gregorianParseFormat.parse(gregorianDateStr)
                            if (parsedDate != null) {
                                val dateKey = keyStorageFormat.format(parsedDate)
                                editor.putString("islamic_date_$dateKey", hijriDateStr)
                                rowsProcessed++
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, "Could not parse date: $gregorianDateStr", e)
                        }
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored Hijri dates for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid Hijri date rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly Hijri dates", e)
            return false
        }
    }

    private fun triggerWidgetUpdate() {
        val appWidgetManager = AppWidgetManager.getInstance(applicationContext)
        val componentName = ComponentName(
            applicationContext.packageName,
            PrayerTimeWidget::class.java.name
        )
        val appWidgetIds = appWidgetManager.getAppWidgetIds(componentName)

        if (appWidgetIds.isNotEmpty()) {
            val intent = Intent(applicationContext, PrayerTimeWidget::class.java).apply {
                action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds)
            }
            applicationContext.sendBroadcast(intent)
            Log.d(TAG, "Broadcast sent to update widget.")
        }
    }
}

// --- file: PrayerTimeWidget.kt ---
package com.ahm.mytime

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import android.os.Build
import android.provider.AlarmClock
import android.provider.CalendarContract
import android.util.Log
import android.widget.RemoteViews
import java.util.*

private val KEY_DATE_FORMAT = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)
private val INPUT_TIME_FORMAT = SimpleDateFormat("HH:mm", Locale.US)
private val OUTPUT_TIME_FORMAT = SimpleDateFormat("h:mm a", Locale.US)

class PrayerTimeWidget : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }
}

data class PrayerSlot(
    val key: String,
    val displayName: String,
    val iconResId: Int,
    val iconViewId: Int,
    val nameViewId: Int,
    val timeViewId: Int
)

internal fun updateAppWidget(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int
) {
    val views = RemoteViews(context.packageName, R.layout.widget_prayer_time)
    val prefs = context.getSharedPreferences(PrayerTimesFetchWorker.PRAYER_PREFS, Context.MODE_PRIVATE)

    updateDateInformation(views)
    updateHijriDate(context, views, prefs)
    updatePrayerTimes(views, prefs)

    setClickListeners(context, views)

    appWidgetManager.updateAppWidget(appWidgetId, views)
    Log.d("PrayerWidget", "Widget UI and click listeners updated for widgetId: $appWidgetId")
}

private fun updateDateInformation(views: RemoteViews) {
    val today = SimpleDateFormat("EEEE", Locale.getDefault()).format(Date())
    views.setTextViewText(R.id.tv_day, today)

    val gregorianDate = SimpleDateFormat("d MMMM yyyy", Locale.getDefault()).format(Date())
    views.setTextViewText(R.id.tv_date, gregorianDate)
}

private fun updateHijriDate(context: Context, views: RemoteViews, prefs: SharedPreferences) {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())
    val dynamicKey = "islamic_date_$todayDateKey"

    val fetchedHijriDate = prefs.getString(dynamicKey, "...")
    views.setTextViewText(R.id.tv_islamic_date_location, fetchedHijriDate)
}

private fun updatePrayerTimes(views: RemoteViews, prefs: SharedPreferences) {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())

    val prayerSlots = listOf(
        PrayerSlot("fajr", "Fajr", R.drawable.ic_fajr, R.id.iv_fajr_icon, R.id.tv_fajr_name, R.id.tv_fajr_time),
        PrayerSlot("sunrise", "Sunrise", R.drawable.ic_sunrise, R.id.iv_sunrise_icon, R.id.tv_sunrise_name, R.id.tv_sunrise_time),
        PrayerSlot("dhuhr", "Dhuhr", R.drawable.ic_dhuhr, R.id.iv_dhuhr_icon, R.id.tv_dhuhr_name, R.id.tv_dhuhr_time),
        PrayerSlot("asr", "Asr", R.drawable.ic_asr, R.id.iv_asr_icon, R.id.tv_asr_name, R.id.tv_asr_time),
        PrayerSlot("maghrib", "Maghrib", R.drawable.ic_maghrib, R.id.iv_maghrib_icon, R.id.tv_maghrib_name, R.id.tv_maghrib_time),
        PrayerSlot("isha", "Isha", R.drawable.ic_isha, R.id.iv_isha_icon, R.id.tv_isha_name, R.id.tv_isha_time)
    )

    prayerSlots.forEach { slot ->
        val dynamicKey = "${slot.key}_$todayDateKey"
        val rawTime24h = prefs.getString(dynamicKey, "--:--")
        val formattedTime12h = formatTime(rawTime24h, INPUT_TIME_FORMAT, OUTPUT_TIME_FORMAT)

        views.setImageViewResource(slot.iconViewId, slot.iconResId)
        views.setTextViewText(slot.nameViewId, slot.displayName)
        views.setTextViewText(slot.timeViewId, formattedTime12h)
    }
}

private fun formatTime(
    timeString: String?,
    inputFormat: SimpleDateFormat,
    outputFormat: SimpleDateFormat
): String {
    return try {
        val date = inputFormat.parse(timeString ?: "--:--")
        outputFormat.format(date ?: Date())
    } catch (e: Exception) {
        timeString ?: "--:--"
    }
}

private fun setClickListeners(context: Context, views: RemoteViews) {
    setDateContainerClickListener(context, views)
    setAlarmClockClickListener(context, views)
}

private fun setDateContainerClickListener(context: Context, views: RemoteViews) {
    val calendarIntent = Intent(Intent.ACTION_VIEW).apply {
        data = CalendarContract.CONTENT_URI.buildUpon()
            .appendPath("time")
            .appendPath(System.currentTimeMillis().toString())
            .build()
        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }

    val calendarPendingIntent = createPendingIntent(context, calendarIntent, requestCode = 0)
    views.setOnClickPendingIntent(R.id.date_container, calendarPendingIntent)
}

private fun setAlarmClockClickListener(context: Context, views: RemoteViews) {
//    val alarmIntent = Intent(AlarmClock.ACTION_SHOW_ALARMS).apply {
//        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
//    }
//
//    if (alarmIntent.resolveActivity(context.packageManager) != null) {
//        val alarmPendingIntent = createPendingIntent(context, alarmIntent, requestCode = 1)
//        views.setOnClickPendingIntent(R.id.clock_container, alarmPendingIntent)
//        views.setOnClickPendingIntent(R.id.prayer_times_layout, alarmPendingIntent)
//    } else {
//        Log.w("PrayerWidget", "No application found to handle ACTION_SHOW_ALARMS intent.")
        setZTEAlarmClockClickListener(context, views)
//    }
}

private fun setZTEAlarmClockClickListener(context: Context, views: RemoteViews) {
    getLaunchAppPendingIntent(context, "zte.com.cn.alarmclock", requestCode = 1)?.let {
        views.setOnClickPendingIntent(R.id.clock_container, it)
        views.setOnClickPendingIntent(R.id.prayer_times_layout, it)
    }
}

private fun getLaunchAppPendingIntent(context: Context, packageName: String, requestCode: Int): PendingIntent? {
    val launchIntent = context.packageManager.getLaunchIntentForPackage(packageName) ?: return null
    return createPendingIntent(context, launchIntent, requestCode)
}

private fun createPendingIntent(context: Context, intent: Intent, requestCode: Int): PendingIntent {
    val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    } else {
        PendingIntent.FLAG_UPDATE_CURRENT
    }
    return PendingIntent.getActivity(context, requestCode, intent, flags)
}

