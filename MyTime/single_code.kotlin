File: app\src\main\AndroidManifest.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Add permissions if needed for location services -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.USE_EXACT_ALARM" />

    <application
        android:name=".MyTimeApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyTime">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Widget Provider -->
        <receiver
            android:name=".PrayerTimeWidget"
            android:exported="true">
            <intent-filter>
                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
            </intent-filter>
            <meta-data
                android:name="android.appwidget.provider"
                android:resource="@xml/prayer_time_widget_info" />
        </receiver>

        <!-- Receiver to re-schedule alarm on boot -->
        <receiver
            android:name=".BootCompletedReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

    </application>

</manifest>
```

File: app\build.gradle.kts
```kts
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.ksp) // Add KSP plugin
    alias(libs.plugins.hilt) // Add Hilt plugin
}

android {
    namespace = "com.ahm.mytime"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.ahm.mytime"
        minSdk = 33
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isShrinkResources = true
            isMinifyEnabled = true
            proguardFiles(
                    getDefaultProguardFile("proguard-android-optimize.txt"),
                    "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        viewBinding = true
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.activity)
    implementation(libs.androidx.constraintlayout)
    implementation(libs.androidx.material3.android)

    // For background data fetching
    implementation(libs.androidx.work.runtime.ktx)

    // For parsing HTML to get prayer times
    implementation("org.jsoup:jsoup:1.17.2")

    // For Islamic Calendar conversion
    implementation("com.github.msarhan:ummalqura-calendar:1.1.1")

    // Retrofit for type-safe HTTP calls
    implementation(libs.retrofit)
    implementation(libs.retrofit.converter.gson)

    // Room dependencies
    implementation(libs.androidx.room.runtime)
    implementation(libs.androidx.room.ktx) // Kotlin Extensions and Coroutines support for Room
    implementation(libs.androidx.room.paging)
    implementation(libs.androidx.hilt.common) // Add Room Paging integration
    ksp(libs.androidx.room.compiler) // Room compiler

    // Hilt dependencies
    implementation(libs.dagger.hilt.android)
    ksp(libs.dagger.hilt.compiler)

    // Hilt-WorkManager Integration
    implementation(libs.androidx.hilt.work)
    ksp(libs.androidx.hilt.compiler)
}
```

File: gradle\libs.versions.toml
```toml
[versions]
agp = "8.12.0"
kotlin = "2.2.0"
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.3.0"
espressoCore = "3.7.0"
appcompat = "1.7.1"
room = "2.7.2"  # Room version
ksp = "2.2.0-2.0.2" # Updated KSP version
hilt = "2.57" # Hilt version
material = "1.12.0"
activity = "1.10.1"
constraintlayout = "2.2.1"
material3Android = "1.3.2"
adhan = "2.0.1"
retrofit = "3.0.0" # A very stable and widely used version
kotlinxCoroutines = "1.10.2"
work = "2.10.3"
hiltCommon = "1.2.0"
hiltWork = "1.2.0" # Add Hilt-Work version

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
androidx-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
androidx-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
androidx-material3-android = { group = "androidx.compose.material3", name = "material3-android", version.ref = "material3Android" }
adhan = { group = "com.batoulapps.adhan2", name = "adhan", version.ref = "adhan" }

# Coroutines
kotlinx-coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android", version.ref = "kotlinxCoroutines" }

# WorkManager for background tasks
androidx-work-runtime-ktx = { group = "androidx.work", name = "work-runtime-ktx", version.ref = "work" }

# Room for local database
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "room" }
androidx-room-paging = { group = "androidx.room", name = "room-paging", version.ref = "room" }  # Add this line
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "room" }

# Retrofit for networking
retrofit = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
retrofit-converter-gson = { group = "com.squareup.retrofit2", name = "converter-gson", version.ref = "retrofit" }

# Hilt
dagger-hilt-android = { group = "com.google.dagger", name = "hilt-android", version.ref = "hilt" }
dagger-hilt-compiler = { group = "com.google.dagger", name = "hilt-compiler", version.ref = "hilt" }
androidx-hilt-common = { group = "androidx.hilt", name = "hilt-common", version.ref = "hiltCommon" }
androidx-hilt-work = { group = "androidx.hilt", name = "hilt-work", version.ref = "hiltWork" } # Add Hilt-Work
androidx-hilt-compiler = { group = "androidx.hilt", name = "hilt-compiler", version.ref = "hiltWork" } # Add Hilt-Compiler for KSP

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }

# Add the Kapt plugin for Room's annotation processor
kotlin-kapt = { id = "org.jetbrains.kotlin.kapt", version.ref = "kotlin" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" } # KSP plugin
hilt = { id = "com.google.dagger.hilt.android", version.ref = "hilt" } # Hilt plugin
```

File: app\src\main\java\com\ahm\mytime\BootCompletedReceiver.kt
```kotlin
package com.ahm.mytime

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class BootCompletedReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d("BootCompletedReceiver", "Device booted, re-scheduling midnight alarm.")
            MidnightAlarmScheduler.scheduleMidnightUpdate(context)
        }
    }
}
```

File: app\src\main\java\com\ahm\mytime\MainActivity.kt
```kotlin
package com.ahm.mytime

import android.annotation.SuppressLint
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.work.*

class MainActivity : AppCompatActivity() {

    companion object {
        private const val DAILY_PRAYER_TIME_WORK_NAME = "DailyPrayerTimeFetchWork"
    }

    @SuppressLint("ResourceType")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        scheduleDailyPrayerTimeWorker()
    }

    private fun scheduleDailyPrayerTimeWorker() {
        val constraints = createNetworkConstraints()
        scheduleOneTimePrayerTimeWork(constraints)
    }

    private fun createNetworkConstraints(): Constraints {
        return Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
    }

    private fun scheduleOneTimePrayerTimeWork(constraints: Constraints) {
        val oneTimeWorkRequest = OneTimeWorkRequestBuilder<PrayerTimesFetchWorker>()
            .setConstraints(constraints)
            .addTag(DAILY_PRAYER_TIME_WORK_NAME)
            .build()

        WorkManager.getInstance(this).enqueueUniqueWork(
            DAILY_PRAYER_TIME_WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            oneTimeWorkRequest
        )
    }
}
```

File: app\src\main\java\com\ahm\mytime\MidnightAlarmScheduler.kt
```kotlin
package com.ahm.mytime

import android.app.AlarmManager
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.os.Build
import android.provider.Settings
import android.util.Log
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.ZonedDateTime

object MidnightAlarmScheduler {

    private const val ALARM_REQUEST_CODE = 101

    fun scheduleMidnightUpdate(context: Context) {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && !alarmManager.canScheduleExactAlarms()) {
            Log.w("MidnightAlarmScheduler", "Cannot schedule exact alarms. Prompting user.")
            // Guide user to settings to grant permission
            Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).also {
                context.startActivity(it)
            }
            return
        }

        val intent = Intent(context, PrayerTimeWidget::class.java).apply {
            action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
            val ids = AppWidgetManager.getInstance(context)
                .getAppWidgetIds(ComponentName(context, PrayerTimeWidget::class.java))
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            ALARM_REQUEST_CODE,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // Calculate next midnight
        val nextMidnight = ZonedDateTime.of(
            LocalDate.now(ZoneId.systemDefault()).plusDays(1),
            LocalTime.MIDNIGHT,
            ZoneId.systemDefault()
        )

        // Use setExactAndAllowWhileIdle for reliability
        alarmManager.setExactAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            nextMidnight.toInstant().toEpochMilli(),
            pendingIntent
        )

        Log.d("MidnightAlarmScheduler", "Midnight widget update alarm scheduled for ${nextMidnight}.")
    }
}
```

File: app\src\main\java\com\ahm\mytime\MyTimeApp.kt
```kotlin
package com.ahm.mytime

import android.app.Application
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.*
import dagger.hilt.android.HiltAndroidApp
import java.util.concurrent.TimeUnit
import javax.inject.Inject

@HiltAndroidApp
class MyTimeApp : Application(), Configuration.Provider {

    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    override val workManagerConfiguration: Configuration
        get() = Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .build()

    override fun onCreate() {
        super.onCreate()
        schedulePrayerTimeFetcher()
    }

    private fun schedulePrayerTimeFetcher() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val periodicWorkRequest = PeriodicWorkRequestBuilder<PrayerTimesFetchWorker>(1, TimeUnit.DAYS)
            .setConstraints(constraints)
            .build()

        WorkManager.getInstance(this).enqueueUniquePeriodicWork(
            "MonthlyPrayerTimeFetchWork",
            ExistingPeriodicWorkPolicy.KEEP,
            periodicWorkRequest
        )
    }
}
```

File: app\src\main\java\com\ahm\mytime\PrayerTimesFetchWorker.kt
```kotlin
package com.ahm.mytime

import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import org.jsoup.Jsoup
import java.util.*

class PrayerTimesFetchWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    companion object {
        const val PRAYER_PREFS = "PrayerTimePrefs"
        private const val TAG = "PrayerTimesFetchWorker"
    }

    override suspend fun doWork(): Result {
        val prefsEditor = applicationContext.getSharedPreferences(PRAYER_PREFS, Context.MODE_PRIVATE).edit()
        var prayerTimesSuccess = false
        var hijriDateSuccess = false

        try {
            prayerTimesSuccess = fetchAndSavePrayerTimes(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching prayer times", e)
        }

        try {
            hijriDateSuccess = fetchAndSaveMonthlyHijriDates(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching Hijri dates", e)
        }

        prefsEditor.apply()

        return if (prayerTimesSuccess && hijriDateSuccess) {
            triggerWidgetUpdate()
            Result.success()
        } else {
            Log.e(TAG, "One or more fetch tasks failed. PrayerSuccess: $prayerTimesSuccess, HijriSuccess: $hijriDateSuccess")
            Result.failure()
        }
    }

    private fun fetchAndSavePrayerTimes(editor: SharedPreferences.Editor): Boolean {
        val prayerUrl = "https://www.waktusolat.my/kedah/kdh05"
        Log.d(TAG, "Fetching monthly prayer times from: $prayerUrl")

        try {
            val prayerDoc = Jsoup.connect(prayerUrl).get()
            val table = prayerDoc.select("table#waktu-semua").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find prayer time table or it has no rows.")
                return false
            }

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 8) {
                    val date = cells[0].select("h6").text()

                    if (date.isNotBlank()) {
                        val fajr = cells[2].text()
                        val sunrise = cells[3].text()
                        val dhuhr = cells[4].text()
                        val asr = cells[5].text()
                        val maghrib = cells[6].text()
                        val isha = cells[7].text()

                        editor.putString("fajr_$date", fajr)
                        editor.putString("sunrise_$date", sunrise)
                        editor.putString("dhuhr_$date", dhuhr)
                        editor.putString("asr_$date", asr)
                        editor.putString("maghrib_$date", maghrib)
                        editor.putString("isha_$date", isha)
                        rowsProcessed++
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored prayer times for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid prayer time rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly prayer times", e)
            return false
        }
    }

    private fun fetchAndSaveMonthlyHijriDates(editor: SharedPreferences.Editor): Boolean {
        val hijriUrl = "https://timesprayer.com/en/hijri-date-in-malaysia.html"
        Log.d(TAG, "Fetching monthly Hijri dates from: $hijriUrl")

        try {
            val doc = Jsoup.connect(hijriUrl).get()
            val table = doc.select("div.prayertable.calendarTb table").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find Hijri date table or it has no rows.")
                return false
            }

            val gregorianParseFormat = SimpleDateFormat("EEEE, MMMM d, yyyy", Locale.ENGLISH)
            val keyStorageFormat = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 2) {
                    val gregorianDateStr = cells[0].text()
                    val hijriDateStr = cells[1].select("strong").text()

                    if (gregorianDateStr.isNotBlank() && hijriDateStr.isNotBlank()) {
                        try {
                            val parsedDate = gregorianParseFormat.parse(gregorianDateStr)
                            if (parsedDate != null) {
                                val dateKey = keyStorageFormat.format(parsedDate)
                                editor.putString("islamic_date_$dateKey", hijriDateStr)
                                rowsProcessed++
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, "Could not parse date: $gregorianDateStr", e)
                        }
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored Hijri dates for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid Hijri date rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly Hijri dates", e)
            return false
        }
    }

    private fun triggerWidgetUpdate() {
        val appWidgetManager = AppWidgetManager.getInstance(applicationContext)
        val componentName = ComponentName(
            applicationContext.packageName,
            PrayerTimeWidget::class.java.name
        )
        val appWidgetIds = appWidgetManager.getAppWidgetIds(componentName)

        if (appWidgetIds.isNotEmpty()) {
            val intent = Intent(applicationContext, PrayerTimeWidget::class.java).apply {
                action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds)
            }
            applicationContext.sendBroadcast(intent)
            Log.d(TAG, "Broadcast sent to update widget.")
        }
    }
}
```

File: app\src\main\java\com\ahm\mytime\PrayerTimeWidget.kt
```kotlin
package com.ahm.mytime

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import android.os.Build
import android.provider.CalendarContract
import android.util.Log
import android.widget.RemoteViews
import java.util.Date
import java.util.Locale

private val KEY_DATE_FORMAT = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)
private val INPUT_TIME_FORMAT = SimpleDateFormat("HH:mm", Locale.US)
private val OUTPUT_TIME_FORMAT = SimpleDateFormat("h:mm a", Locale.US)

class PrayerTimeWidget : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }
}

data class PrayerSlot(
    val key: String,
    val displayName: String,
    val iconResId: Int,
    val iconViewId: Int,
    val nameViewId: Int,
    val timeViewId: Int
)

internal fun updateAppWidget(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int
) {
    val views = RemoteViews(context.packageName, R.layout.widget_prayer_time)
    val prefs = context.getSharedPreferences(PrayerTimesFetchWorker.PRAYER_PREFS, Context.MODE_PRIVATE)

    updateDateInformation(views)
    updateHijriDate(context, views, prefs)
    updatePrayerTimes(views, prefs)

    setClickListeners(context, views)

    appWidgetManager.updateAppWidget(appWidgetId, views)
    Log.d("PrayerWidget", "Widget UI and click listeners updated for widgetId: $appWidgetId")
}

private fun updateDateInformation(views: RemoteViews) {
    val today = SimpleDateFormat("EEEE", Locale.getDefault()).format(Date())
    views.setTextViewText(R.id.tv_day, today)

    val gregorianDate = SimpleDateFormat("d MMMM yyyy", Locale.getDefault()).format(Date())
    views.setTextViewText(R.id.tv_date, gregorianDate)
}

private fun updateHijriDate(context: Context, views: RemoteViews, prefs: SharedPreferences) {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())
    val dynamicKey = "islamic_date_$todayDateKey"

    val fetchedHijriDate = prefs.getString(dynamicKey, "...")
    views.setTextViewText(R.id.tv_islamic_date_location, fetchedHijriDate)
}

private fun updatePrayerTimes(views: RemoteViews, prefs: SharedPreferences) {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())

    val prayerSlots = listOf(
        PrayerSlot("fajr", "Fajr", R.drawable.ic_fajr, R.id.iv_fajr_icon, R.id.tv_fajr_name, R.id.tv_fajr_time),
        PrayerSlot("sunrise", "Sunrise", R.drawable.ic_sunrise, R.id.iv_sunrise_icon, R.id.tv_sunrise_name, R.id.tv_sunrise_time),
        PrayerSlot("dhuhr", "Dhuhr", R.drawable.ic_dhuhr, R.id.iv_dhuhr_icon, R.id.tv_dhuhr_name, R.id.tv_dhuhr_time),
        PrayerSlot("asr", "Asr", R.drawable.ic_asr, R.id.iv_asr_icon, R.id.tv_asr_name, R.id.tv_asr_time),
        PrayerSlot("maghrib", "Maghrib", R.drawable.ic_maghrib, R.id.iv_maghrib_icon, R.id.tv_maghrib_name, R.id.tv_maghrib_time),
        PrayerSlot("isha", "Isha", R.drawable.ic_isha, R.id.iv_isha_icon, R.id.tv_isha_name, R.id.tv_isha_time)
    )

    prayerSlots.forEach { slot ->
        val dynamicKey = "${slot.key}_$todayDateKey"
        val rawTime24h = prefs.getString(dynamicKey, "--:--")
        val formattedTime12h = formatTime(rawTime24h, INPUT_TIME_FORMAT, OUTPUT_TIME_FORMAT)

        views.setImageViewResource(slot.iconViewId, slot.iconResId)
        views.setTextViewText(slot.nameViewId, slot.displayName)
        views.setTextViewText(slot.timeViewId, formattedTime12h)
    }
}

private fun formatTime(
    timeString: String?,
    inputFormat: SimpleDateFormat,
    outputFormat: SimpleDateFormat
): String {
    return try {
        val date = inputFormat.parse(timeString ?: "--:--")
        outputFormat.format(date ?: Date())
    } catch (e: Exception) {
        timeString ?: "--:--"
    }
}

private fun setClickListeners(context: Context, views: RemoteViews) {
    setDateContainerClickListener(context, views)
    setAlarmClockClickListener(context, views)
}

private fun setDateContainerClickListener(context: Context, views: RemoteViews) {
    val calendarIntent = Intent(Intent.ACTION_VIEW).apply {
        data = CalendarContract.CONTENT_URI.buildUpon()
            .appendPath("time")
            .appendPath(System.currentTimeMillis().toString())
            .build()
        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }

    val calendarPendingIntent = createPendingIntent(context, calendarIntent, requestCode = 0)
    views.setOnClickPendingIntent(R.id.date_container, calendarPendingIntent)
}

private fun setAlarmClockClickListener(context: Context, views: RemoteViews) {
    getLaunchAppPendingIntent(context, "zte.com.cn.alarmclock", requestCode = 1)?.let {
        views.setOnClickPendingIntent(R.id.clock_container, it)
        views.setOnClickPendingIntent(R.id.prayer_times_layout, it)
    }
}

private fun getLaunchAppPendingIntent(context: Context, packageName: String, requestCode: Int): PendingIntent? {
    val launchIntent = context.packageManager.getLaunchIntentForPackage(packageName) ?: return null
    return createPendingIntent(context, launchIntent, requestCode)
}

private fun createPendingIntent(context: Context, intent: Intent, requestCode: Int): PendingIntent {
    val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    } else {
        PendingIntent.FLAG_UPDATE_CURRENT
    }
    return PendingIntent.getActivity(context, requestCode, intent, flags)
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTime.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "prayer_times")
data class PrayerTime(
    @PrimaryKey val date: String, // Format: "dd-MM-yyyy"
    val hijriDate: String,
    val fajr: String,
    val sunrise: String,
    val dhuhr: String,
    val asr: String,
    val maghrib: String,
    val isha: String
)
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeDao.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface PrayerTimeDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(prayerTimes: List<PrayerTime>)

    @Query("SELECT * FROM prayer_times WHERE date = :date LIMIT 1")
    suspend fun getPrayerTimeForDate(date: String): PrayerTime?

    @Query("SELECT * FROM prayer_times ORDER BY date ASC")
    fun getAllPrayerTimes(): Flow<List<PrayerTime>>

    @Query("DELETE FROM prayer_times")
    suspend fun clearAll()
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeDatabase.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Database
import androidx.room.RoomDatabase

@Database(entities = [PrayerTime::class], version = 1, exportSchema = false)
abstract class PrayerTimeDatabase : RoomDatabase() {
    abstract fun prayerTimeDao(): PrayerTimeDao
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeRepository.kt
```kotlin
package com.ahm.mytime.data

import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PrayerTimeRepository @Inject constructor(private val prayerTimeDao: PrayerTimeDao) {
    suspend fun getPrayerTimeForDate(date: String): PrayerTime? = prayerTimeDao.getPrayerTimeForDate(date)
    suspend fun insertPrayerTimes(prayerTimes: List<PrayerTime>) {
        prayerTimeDao.insertAll(prayerTimes)
    }
}
```

File: app\src\main\java\com\ahm\mytime\di\AppModule.kt
```kotlin
package com.ahm.mytime.di

import android.content.Context
import androidx.room.Room
import com.ahm.mytime.data.PrayerTimeDao
import com.ahm.mytime.data.PrayerTimeDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun providePrayerTimeDatabase(@ApplicationContext context: Context): PrayerTimeDatabase {
        return Room.databaseBuilder(
            context,
            PrayerTimeDatabase::class.java,
            "prayer_time_database"
        ).build()
    }

    @Provides
    fun providePrayerTimeDao(database: PrayerTimeDatabase): PrayerTimeDao {
        return database.prayerTimeDao()
    }
}
```

