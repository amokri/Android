File: app\src\main\java\com\ahm\mytime\BootCompletedReceiver.kt
```kotlin
package com.ahm.mytime

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class BootCompletedReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d("BootCompletedReceiver", "Device booted, re-scheduling midnight alarm.")
            MidnightAlarmScheduler.scheduleMidnightUpdate(context)
        }
    }
}
```

File: app\src\main\java\com\ahm\mytime\MainActivity.kt
```kotlin
package com.ahm.mytime

import android.content.Intent
import android.os.Bundle
import android.provider.CalendarContract
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.work.*
import com.ahm.mytime.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    companion object {
        private const val DAILY_PRAYER_TIME_WORK_NAME = "DailyPrayerTimeFetchWork"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupClickListeners()
        scheduleOneTimePrayerTimeWorker()
    }

    override fun onResume() {
        super.onResume()
        updateUI()
    }

    private fun setupClickListeners() {
        // Refresh button listener
        binding.refreshButton.setOnClickListener {
            Toast.makeText(this, "Refreshing data...", Toast.LENGTH_SHORT).show()
            scheduleOneTimePrayerTimeWorker()
        }

        // Calendar click listener
        binding.clock.dateContainer.setOnClickListener {
            val calendarIntent = Intent(Intent.ACTION_VIEW).apply {
                data = CalendarContract.CONTENT_URI.buildUpon()
                    .appendPath("time")
                    .appendPath(System.currentTimeMillis().toString())
                    .build()
            }
            try {
                startActivity(calendarIntent)
            } catch (e: Exception) {
                Toast.makeText(this, "Could not open Calendar app", Toast.LENGTH_SHORT).show()
            }
        }

        // Alarm clock click listener
        val alarmClockListener = View.OnClickListener {
            val packageName = "zte.com.cn.alarmclock" // As defined in the widget
            val launchIntent = packageManager.getLaunchIntentForPackage(packageName)
            if (launchIntent != null) {
                try {
                    startActivity(launchIntent)
                } catch (e: Exception) {
                    Toast.makeText(this, "Could not open Alarm Clock app", Toast.LENGTH_SHORT).show()
                }
            } else {
                Toast.makeText(this, "Alarm Clock app not found", Toast.LENGTH_SHORT).show()
            }
        }

        binding.clock.clockContainer.setOnClickListener(alarmClockListener)
        binding.clock.prayerTimesLayout.setOnClickListener(alarmClockListener)
    }

    private fun updateUI() {
        binding.statusText.visibility = View.VISIBLE

        // Update date info
        binding.clock.tvDay.text = getTodayDayName()
        binding.clock.tvDate.text = getTodayGregorianDate()

        val prefs = getPrefs(this)
        binding.clock.tvIslamicDateLocation.text = getTodayHijriDate(prefs)

        // Update prayer times
        val prayerViewMap = mapOf(
            "fajr" to Triple(binding.clock.ivFajrIcon, binding.clock.tvFajrName, binding.clock.tvFajrTime),
            "sunrise" to Triple(binding.clock.ivSunriseIcon, binding.clock.tvSunriseName, binding.clock.tvSunriseTime),
            "dhuhr" to Triple(binding.clock.ivDhuhrIcon, binding.clock.tvDhuhrName, binding.clock.tvDhuhrTime),
            "asr" to Triple(binding.clock.ivAsrIcon, binding.clock.tvAsrName, binding.clock.tvAsrTime),
            "maghrib" to Triple(binding.clock.ivMaghribIcon, binding.clock.tvMaghribName, binding.clock.tvMaghribTime),
            "isha" to Triple(binding.clock.ivIshaIcon, binding.clock.tvIshaName, binding.clock.tvIshaTime)
        )

        prayerSlotsInfo.forEach { slotInfo ->
            prayerViewMap[slotInfo.key]?.let { (iconView, nameView, timeView) ->
                val rawTime24h = getPrayerTime(prefs, slotInfo.key)
                iconView.setImageResource(slotInfo.iconResId)
                nameView.text = slotInfo.displayName
                timeView.text = formatTime12h(rawTime24h)
            }
        }

        binding.statusText.visibility = View.GONE
    }

    private fun scheduleOneTimePrayerTimeWorker() {
        val oneTimeWorkRequest = OneTimeWorkRequestBuilder<PrayerTimesFetchWorker>()
            .setConstraints(createNetworkConstraints())
            .addTag(DAILY_PRAYER_TIME_WORK_NAME)
            .build()

        WorkManager.getInstance(this).enqueueUniqueWork(
            DAILY_PRAYER_TIME_WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            oneTimeWorkRequest
        )
    }
}
```

File: app\src\main\java\com\ahm\mytime\MidnightAlarmScheduler.kt
```kotlin
package com.ahm.mytime

import android.app.AlarmManager
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.os.Build
import android.provider.Settings
import android.util.Log
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.ZonedDateTime

object MidnightAlarmScheduler {

    private const val ALARM_REQUEST_CODE = 101

    fun scheduleMidnightUpdate(context: Context) {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && !alarmManager.canScheduleExactAlarms()) {
            Log.w("MidnightAlarmScheduler", "Cannot schedule exact alarms. Prompting user.")
            // Guide user to settings to grant permission
            Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).also {
                context.startActivity(it)
            }
            return
        }

        val intent = Intent(context, PrayerTimeWidget::class.java).apply {
            action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
            val ids = AppWidgetManager.getInstance(context)
                .getAppWidgetIds(ComponentName(context, PrayerTimeWidget::class.java))
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            ALARM_REQUEST_CODE,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // Calculate next midnight
        val nextMidnight = ZonedDateTime.of(
            LocalDate.now(ZoneId.systemDefault()).plusDays(1),
            LocalTime.MIDNIGHT,
            ZoneId.systemDefault()
        )

        // Use setExactAndAllowWhileIdle for reliability
        alarmManager.setExactAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            nextMidnight.toInstant().toEpochMilli(),
            pendingIntent
        )

        Log.d("MidnightAlarmScheduler", "Midnight widget update alarm scheduled for ${nextMidnight}.")
    }
}
```

File: app\src\main\java\com\ahm\mytime\MyTimeApp.kt
```kotlin
package com.ahm.mytime

import android.app.Application
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.*
import dagger.hilt.android.HiltAndroidApp
import java.util.concurrent.TimeUnit
import javax.inject.Inject

@HiltAndroidApp
class MyTimeApp : Application(), Configuration.Provider {

    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    override val workManagerConfiguration: Configuration
        get() = Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .build()

    override fun onCreate() {
        super.onCreate()
        schedulePrayerTimeFetcher()
    }

    private fun schedulePrayerTimeFetcher() {
        val periodicWorkRequest = PeriodicWorkRequestBuilder<PrayerTimesFetchWorker>(1, TimeUnit.DAYS)
            .setConstraints(createNetworkConstraints())
            .build()

        WorkManager.getInstance(this).enqueueUniquePeriodicWork(
            "MonthlyPrayerTimeFetchWork",
            ExistingPeriodicWorkPolicy.REPLACE,
            periodicWorkRequest
        )
    }
}
```

File: app\src\main\java\com\ahm\mytime\PrayerTimeHelper.kt
```kotlin
package com.ahm.mytime

import android.content.Context
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import java.util.*

// Shared Formatting
internal val KEY_DATE_FORMAT = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)
private val INPUT_TIME_FORMAT = SimpleDateFormat("HH:mm", Locale.US)
private val OUTPUT_TIME_FORMAT = SimpleDateFormat("h:mm a", Locale.US)

// Shared Data
data class PrayerSlotInfo(val key: String, val displayName: String, val iconResId: Int)

internal val prayerSlotsInfo = listOf(
    PrayerSlotInfo("fajr", "Fajr", R.drawable.ic_fajr),
    PrayerSlotInfo("sunrise", "Sunrise", R.drawable.ic_sunrise),
    PrayerSlotInfo("dhuhr", "Dhuhr", R.drawable.ic_dhuhr),
    PrayerSlotInfo("asr", "Asr", R.drawable.ic_asr),
    PrayerSlotInfo("maghrib", "Maghrib", R.drawable.ic_maghrib),
    PrayerSlotInfo("isha", "Isha", R.drawable.ic_isha)
)

// Shared Logic
internal fun getPrefs(context: Context): SharedPreferences {
    return context.getSharedPreferences(PrayerTimesFetchWorker.PRAYER_PREFS, Context.MODE_PRIVATE)
}

internal fun formatTime12h(timeString: String?): String {
    return try {
        val date = INPUT_TIME_FORMAT.parse(timeString ?: "--:--")
        OUTPUT_TIME_FORMAT.format(date ?: Date())
    } catch (e: Exception) {
        timeString ?: "--:--"
    }
}

internal fun getTodayDayName(): String = SimpleDateFormat("EEEE", Locale.getDefault()).format(Date())

internal fun getTodayGregorianDate(): String = SimpleDateFormat("d MMMM yyyy", Locale.getDefault()).format(Date())

internal fun getTodayHijriDate(prefs: SharedPreferences): String {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())
    val dynamicKey = "islamic_date_$todayDateKey"
    return prefs.getString(dynamicKey, "...") ?: "..."
}

internal fun getPrayerTime(prefs: SharedPreferences, prayerKey: String): String {
    val todayDateKey = KEY_DATE_FORMAT.format(Date())
    val dynamicKey = "${prayerKey}_$todayDateKey"
    return prefs.getString(dynamicKey, "--:--") ?: "--:--"
}
```

File: app\src\main\java\com\ahm\mytime\PrayerTimesFetchWorker.kt
```kotlin
package com.ahm.mytime

import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.icu.text.SimpleDateFormat
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import org.jsoup.Jsoup
import java.util.*

class PrayerTimesFetchWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    companion object {
        const val PRAYER_PREFS = "PrayerTimePrefs"
        private const val TAG = "PrayerTimesFetchWorker"
    }

    override suspend fun doWork(): Result {
        val prefsEditor = applicationContext.getSharedPreferences(PRAYER_PREFS, Context.MODE_PRIVATE).edit()
        var prayerTimesSuccess = false
        var hijriDateSuccess = false

        try {
            prayerTimesSuccess = fetchAndSavePrayerTimes(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching prayer times", e)
        }

        try {
            hijriDateSuccess = fetchAndSaveMonthlyHijriDates(prefsEditor)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching Hijri dates", e)
        }

        prefsEditor.apply()

        return if (prayerTimesSuccess && hijriDateSuccess) {
            triggerWidgetUpdate()
            Result.success()
        } else {
            Log.e(TAG, "One or more fetch tasks failed. PrayerSuccess: $prayerTimesSuccess, HijriSuccess: $hijriDateSuccess")
            Result.failure()
        }
    }

    private fun fetchAndSavePrayerTimes(editor: SharedPreferences.Editor): Boolean {
        val prayerUrl = "https://www.waktusolat.my/kedah/kdh05"
        Log.d(TAG, "Fetching monthly prayer times from: $prayerUrl")

        try {
            val prayerDoc = Jsoup.connect(prayerUrl).get()
            val table = prayerDoc.select("table#waktu-semua").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find prayer time table or it has no rows.")
                return false
            }

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 8) {
                    val date = cells[0].select("h6").text()

                    if (date.isNotBlank()) {
                        val fajr = cells[2].text()
                        val sunrise = cells[3].text()
                        val dhuhr = cells[4].text()
                        val asr = cells[5].text()
                        val maghrib = cells[6].text()
                        val isha = cells[7].text()

                        editor.putString("fajr_$date", fajr)
                        editor.putString("sunrise_$date", sunrise)
                        editor.putString("dhuhr_$date", dhuhr)
                        editor.putString("asr_$date", asr)
                        editor.putString("maghrib_$date", maghrib)
                        editor.putString("isha_$date", isha)
                        rowsProcessed++
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored prayer times for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid prayer time rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly prayer times", e)
            return false
        }
    }

    private fun fetchAndSaveMonthlyHijriDates(editor: SharedPreferences.Editor): Boolean {
        val hijriUrl = "https://timesprayer.com/en/hijri-date-in-malaysia.html"
        Log.d(TAG, "Fetching monthly Hijri dates from: $hijriUrl")

        try {
            val doc = Jsoup.connect(hijriUrl).get()
            val table = doc.select("div.prayertable.calendarTb table").firstOrNull()
            val rows = table?.select("tbody tr")

            if (rows.isNullOrEmpty()) {
                Log.e(TAG, "Could not find Hijri date table or it has no rows.")
                return false
            }

            val gregorianParseFormat = SimpleDateFormat("EEEE, MMMM d, yyyy", Locale.ENGLISH)
            val keyStorageFormat = SimpleDateFormat("dd-MM-yyyy", Locale.ENGLISH)

            var rowsProcessed = 0
            rows.forEach { row ->
                val cells = row.select("td")
                if (cells.size >= 2) {
                    val gregorianDateStr = cells[0].text()
                    val hijriDateStr = cells[1].select("strong").text()

                    if (gregorianDateStr.isNotBlank() && hijriDateStr.isNotBlank()) {
                        try {
                            val parsedDate = gregorianParseFormat.parse(gregorianDateStr)
                            if (parsedDate != null) {
                                val dateKey = keyStorageFormat.format(parsedDate)
                                editor.putString("islamic_date_$dateKey", hijriDateStr)
                                rowsProcessed++
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, "Could not parse date: $gregorianDateStr", e)
                        }
                    }
                }
            }

            return if (rowsProcessed > 0) {
                Log.d(TAG, "Successfully parsed and stored Hijri dates for $rowsProcessed days.")
                true
            } else {
                Log.e(TAG, "No valid Hijri date rows were processed.")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception while fetching or parsing monthly Hijri dates", e)
            return false
        }
    }

    private fun triggerWidgetUpdate() {
        val appWidgetManager = AppWidgetManager.getInstance(applicationContext)
        val componentName = ComponentName(
            applicationContext.packageName,
            PrayerTimeWidget::class.java.name
        )
        val appWidgetIds = appWidgetManager.getAppWidgetIds(componentName)

        if (appWidgetIds.isNotEmpty()) {
            val intent = Intent(applicationContext, PrayerTimeWidget::class.java).apply {
                action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds)
            }
            applicationContext.sendBroadcast(intent)
            Log.d(TAG, "Broadcast sent to update widget.")
        }
    }
}
```

File: app\src\main\java\com\ahm\mytime\PrayerTimeWidget.kt
```kotlin
package com.ahm.mytime

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.os.Build
import android.provider.CalendarContract
import android.util.Log
import android.widget.RemoteViews
import java.util.*

class PrayerTimeWidget : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        // Re-schedule the midnight alarm upon widget update (e.g., device reboot or new widget)
        MidnightAlarmScheduler.scheduleMidnightUpdate(context)

        appWidgetIds.forEach { appWidgetId ->
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }
}

// A private data class to map prayer slot data to the specific views in this widget's layout
private data class PrayerSlotViews(val iconViewId: Int, val nameViewId: Int, val timeViewId: Int)

internal fun updateAppWidget(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int
) {
    val views = RemoteViews(context.packageName, R.layout.widget_prayer_time)
    val prefs = getPrefs(context)

    // Update date information
    views.setTextViewText(R.id.tv_day, getTodayDayName())
    views.setTextViewText(R.id.tv_date, getTodayGregorianDate())
    views.setTextViewText(R.id.tv_islamic_date_location, getTodayHijriDate(prefs))

    // Map shared prayer slot info to the specific views in this widget layout
    val prayerViewMappings = mapOf(
        "fajr" to PrayerSlotViews(R.id.iv_fajr_icon, R.id.tv_fajr_name, R.id.tv_fajr_time),
        "sunrise" to PrayerSlotViews(R.id.iv_sunrise_icon, R.id.tv_sunrise_name, R.id.tv_sunrise_time),
        "dhuhr" to PrayerSlotViews(R.id.iv_dhuhr_icon, R.id.tv_dhuhr_name, R.id.tv_dhuhr_time),
        "asr" to PrayerSlotViews(R.id.iv_asr_icon, R.id.tv_asr_name, R.id.tv_asr_time),
        "maghrib" to PrayerSlotViews(R.id.iv_maghrib_icon, R.id.tv_maghrib_name, R.id.tv_maghrib_time),
        "isha" to PrayerSlotViews(R.id.iv_isha_icon, R.id.tv_isha_name, R.id.tv_isha_time)
    )

    // Update prayer times using the shared helper data and functions
    prayerSlotsInfo.forEach { slotInfo ->
        prayerViewMappings[slotInfo.key]?.let { viewIds ->
            val rawTime24h = getPrayerTime(prefs, slotInfo.key)
            val formattedTime12h = formatTime12h(rawTime24h)

            views.setImageViewResource(viewIds.iconViewId, slotInfo.iconResId)
            views.setTextViewText(viewIds.nameViewId, slotInfo.displayName)
            views.setTextViewText(viewIds.timeViewId, formattedTime12h)
        }
    }

    setClickListeners(context, views)

    appWidgetManager.updateAppWidget(appWidgetId, views)
    Log.d("PrayerWidget", "Widget UI and click listeners updated for widgetId: $appWidgetId")
}

private fun setClickListeners(context: Context, views: RemoteViews) {
    setDateContainerClickListener(context, views)
    setAlarmClockClickListener(context, views)
}

private fun setDateContainerClickListener(context: Context, views: RemoteViews) {
    val calendarIntent = Intent(Intent.ACTION_VIEW).apply {
        data = CalendarContract.CONTENT_URI.buildUpon()
            .appendPath("time")
            .appendPath(System.currentTimeMillis().toString())
            .build()
        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }

    val calendarPendingIntent = createPendingIntent(context, calendarIntent, requestCode = 0)
    views.setOnClickPendingIntent(R.id.date_container, calendarPendingIntent)
}

private fun setAlarmClockClickListener(context: Context, views: RemoteViews) {
    getLaunchAppPendingIntent(context, "zte.com.cn.alarmclock", requestCode = 1)?.let {
        views.setOnClickPendingIntent(R.id.clock_container, it)
        views.setOnClickPendingIntent(R.id.prayer_times_layout, it)
    }
}

private fun getLaunchAppPendingIntent(context: Context, packageName: String, requestCode: Int): PendingIntent? {
    val launchIntent = context.packageManager.getLaunchIntentForPackage(packageName) ?: return null
    return createPendingIntent(context, launchIntent, requestCode)
}

private fun createPendingIntent(context: Context, intent: Intent, requestCode: Int): PendingIntent {
    val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    } else {
        PendingIntent.FLAG_UPDATE_CURRENT
    }
    return PendingIntent.getActivity(context, requestCode, intent, flags)
}
```

File: app\src\main\java\com\ahm\mytime\WorkerUtils.kt
```kotlin
package com.ahm.mytime

import androidx.work.Constraints
import androidx.work.NetworkType

internal fun createNetworkConstraints(): Constraints {
    return Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .build()
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTime.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "prayer_times")
data class PrayerTime(
    @PrimaryKey val date: String, // Format: "dd-MM-yyyy"
    val hijriDate: String,
    val fajr: String,
    val sunrise: String,
    val dhuhr: String,
    val asr: String,
    val maghrib: String,
    val isha: String
)
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeDao.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface PrayerTimeDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(prayerTimes: List<PrayerTime>)

    @Query("SELECT * FROM prayer_times WHERE date = :date LIMIT 1")
    suspend fun getPrayerTimeForDate(date: String): PrayerTime?

    @Query("SELECT * FROM prayer_times ORDER BY date ASC")
    fun getAllPrayerTimes(): Flow<List<PrayerTime>>

    @Query("DELETE FROM prayer_times")
    suspend fun clearAll()
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeDatabase.kt
```kotlin
package com.ahm.mytime.data

import androidx.room.Database
import androidx.room.RoomDatabase

@Database(entities = [PrayerTime::class], version = 1, exportSchema = false)
abstract class PrayerTimeDatabase : RoomDatabase() {
    abstract fun prayerTimeDao(): PrayerTimeDao
}
```

File: app\src\main\java\com\ahm\mytime\data\PrayerTimeRepository.kt
```kotlin
package com.ahm.mytime.data

import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PrayerTimeRepository @Inject constructor(private val prayerTimeDao: PrayerTimeDao) {
    suspend fun getPrayerTimeForDate(date: String): PrayerTime? = prayerTimeDao.getPrayerTimeForDate(date)
    suspend fun insertPrayerTimes(prayerTimes: List<PrayerTime>) {
        prayerTimeDao.insertAll(prayerTimes)
    }
}
```

File: app\src\main\java\com\ahm\mytime\di\AppModule.kt
```kotlin
package com.ahm.mytime.di

import android.content.Context
import androidx.room.Room
import com.ahm.mytime.data.PrayerTimeDao
import com.ahm.mytime.data.PrayerTimeDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun providePrayerTimeDatabase(@ApplicationContext context: Context): PrayerTimeDatabase {
        return Room.databaseBuilder(
            context,
            PrayerTimeDatabase::class.java,
            "prayer_time_database"
        ).build()
    }

    @Provides
    fun providePrayerTimeDao(database: PrayerTimeDatabase): PrayerTimeDao {
        return database.prayerTimeDao()
    }
}
```

